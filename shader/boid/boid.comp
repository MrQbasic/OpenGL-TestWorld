#version 430 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 0) buffer Vec3Buffer {
    float data[];
};

uniform vec3 u_cageSize;
float borderMargin = 1.0f;

float speedFactor = 0.05;

float speedMax = 3.0f * speedFactor;
float speedMin = 2.0f * speedFactor;

float visionRad = 2.0f;
float avoidRad  = 0.5f;

float centerFactor  = 0.005;
float matchinFactor = 0.05f;
float avoidFactor   = 0.05f;
float turnfactor    = 1.0f;

float randomFloat(float salt) {
    float hash = fract(sin(salt) * 43758.5453123);
    hash *= 2;
    hash -1;
    return hash;
}

void main() {
    //get index of current boid
    uvec3 id = gl_GlobalInvocationID;
    uint index = id.z * (gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_NumWorkGroups.y * gl_WorkGroupSize.y) + 
                 id.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + id.x;

    //get data of current boid
    vec3 boidPos = vec3(data[index*6+0], data[index*6+1], data[index*6+2]);
    vec3 boidVel = vec3(data[index*6+3], data[index*6+4], data[index*6+5]);
    
    int cnt = 0;
    int cnt2 = 0;
    vec3 velSum = vec3(0);
    vec3 posSum = vec3(0);
    vec3 avoidSum = vec3(0);

    for(int i=0; i<100; i++){
        if(i != index){
            vec3 otherBoidPos = vec3(data[i*6+0], data[i*6+1], data[i*6+2]);
            float dist = distance(boidPos, otherBoidPos);
            if(dist < avoidRad){
                cnt2++;
                avoidSum += boidPos - otherBoidPos;
            }
            if(dist < visionRad){
                cnt++;
                posSum += otherBoidPos;
                velSum += vec3(data[i*6+3], data[i*6+4], data[i*6+5]);
            }     
        }
    }
    velSum /= cnt;
    posSum /= cnt;

    //calculate rotation needed to steer to center of crowd
    vec3 toCenter = posSum - boidPos;

    //calc new dir
    if(cnt != 0){
        boidVel += toCenter * centerFactor;
        boidVel += velSum   * matchinFactor;
    }
    if(cnt2 != 0){
        boidVel += avoidSum     * avoidFactor;
    }

    //enforce turning    //Todo remove ifs for optim
    float distOutside = 0;
    if(any(lessThan(boidPos, vec3(borderMargin)))){
        distOutside = max(max(borderMargin-boidPos.x, borderMargin-boidPos.y), borderMargin-boidPos.z);
    }else if(any(greaterThan(boidPos, u_cageSize-vec3(borderMargin)))){
        distOutside = max(max(boidPos.x-u_cageSize.x, boidPos.y-u_cageSize.y), boidPos.z-u_cageSize.z);
    }
    
    float turnBias = abs(distOutside)/10;

    vec3 centerPtr = (u_cageSize/3)-boidPos;
    boidVel += centerPtr * turnBias;
    
    //min and max speed
    float speed = clamp(distance(boidVel, vec3(0)) ,speedMin, speedMax);
    boidVel = boidVel / distance(boidVel, vec3(0)) * speed;

    //move the boid
    boidPos += boidVel;

    //write back data
    data[index*6+0] = boidPos.x;
    data[index*6+1] = boidPos.y;
    data[index*6+2] = boidPos.z;
    data[index*6+3] = boidVel.x;
    data[index*6+4] = boidVel.y;
    data[index*6+5] = boidVel.z;
}
